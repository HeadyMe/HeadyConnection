#!/usr/bin/env python3
"""
Heady Golden Master Builder (v1.0.0)
====================================

This script scans a given repository on the local filesystem, collects all
relevant source files and documentation, and produces a clean installation
package. The goal of the golden master builder is to assemble a minimal,
coherent set of files that are required to run the project while stripping
away temporary artefacts such as caches, compiled bytecode and other
unnecessary clutter.
"""

import argparse
import hashlib
import json
import os
import shutil
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, Iterable, List, Tuple

# File extensions that should be included in the package
INCLUDE_EXTENSIONS: Tuple[str, ...] = (".py", ".md", ".rst", ".txt", ".sh")

# Directory names to exclude from scanning
EXCLUDE_DIRS: Tuple[str, ...] = (
    ".git",
    "__pycache__",
    "build",
    "dist",
    ".mypy_cache",
    ".pytest_cache",
    ".ipynb_checkpoints"
)

def compute_sha256(path: Path, chunk_size: int = 65536) -> str:
    """Compute the SHAâ€‘256 checksum of a file."""
    hasher = hashlib.sha256()
    with open(path, "rb") as f:
        while True:
            chunk = f.read(chunk_size)
            if not chunk:
                break
            hasher.update(chunk)
    return hasher.hexdigest()

def should_include_file(path: Path) -> bool:
    """Return True if the file should be included in the package."""
    return path.suffix in INCLUDE_EXTENSIONS

def collect_files(source_dir: Path) -> List[Path]:
    """Traverse the source directory and collect files to include."""
    included: List[Path] = []
    for root, dirs, files in os.walk(source_dir):
        # Skip excluded directories in-place
        dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]
        for name in files:
            file_path = Path(root) / name
            if should_include_file(file_path):
                included.append(file_path)
    return included

def copy_files(files: Iterable[Path], source_dir: Path, dest_dir: Path) -> Dict[str, Dict[str, str]]:
    """Copy files into dest_dir preserving relative paths.
    Returns a manifest mapping relative paths to metadata (size and checksum).
    """
    manifest: Dict[str, Dict[str, str]] = {}
    for file_path in files:
        rel_path = file_path.relative_to(source_dir)
        dest_path = dest_dir / rel_path
        dest_path.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(file_path, dest_path)
        metadata = {
            "size_bytes": str(file_path.stat().st_size),
            "sha256": compute_sha256(file_path),
        }
        manifest[str(rel_path)] = metadata
    return manifest

def write_manifest(dest_dir: Path, manifest: Dict[str, Dict[str, str]], version: str) -> None:
    """Write the installation manifest (JSON) to the destination directory."""
    manifest_path = dest_dir / "installation_manifest.json"
    payload = {
        "generated_at": datetime.utcnow().isoformat() + "Z",
        "version": version,
        "files": manifest,
    }
    with open(manifest_path, "w") as f:
        json.dump(payload, f, indent=2)

def write_readme(dest_dir: Path, version: str) -> None:
    """Write a simple README file explaining the package."""
    readme_path = dest_dir / "README.txt"
    content = f"""HeadySystems Installation Package
================================

This package was generated by the Heady Golden Master Builder v{version}.
It contains the essential source code and documentation required to run the
Heady project.

Structure:
  - installation_manifest.json: Machineâ€‘readable list of included files with
    checksums and sizes.
  - README.txt: This file.
  - src/: Relative copy of the source files from the original repository.

To install, copy the contents of this directory to your desired location or
extract the accompanying ZIP archive. Consult the project's documentation
for further setup instructions.

Generated on: {datetime.utcnow().isoformat()}Z
"""
    with open(readme_path, "w") as f:
        f.write(content)

def create_zip(dest_dir: Path, version: str) -> None:
    """Create a ZIP archive of the destination directory."""
    archive_name = f"HeadySystems_package_v{version.replace('.', '_')}"
    shutil.make_archive(base_name=str(dest_dir.parent / archive_name), format="zip", root_dir=dest_dir)

def main() -> None:
    parser = argparse.ArgumentParser(description="Build a clean installation package for HeadySystems.")
    parser.add_argument("--source-dir", type=str, required=True, help="Path to the root of the repository to scan.")
    parser.add_argument("--output-dir", type=str, required=True, help="Destination directory for the package.")
    parser.add_argument("--version", type=str, default="1.0.0", help="Version number for the package and builder script.")
    parser.add_argument("--zip", action="store_true", help="Create a ZIP archive of the package.")
    args = parser.parse_args()

    source_dir = Path(args.source_dir).resolve()
    dest_dir = Path(args.output_dir).resolve() / f"HeadySystems_package_v{args.version.replace('.', '_')}"

    if not source_dir.is_dir():
        print(f"âŒ Source directory does not exist: {source_dir}", file=sys.stderr)
        sys.exit(1)
    # Prepare destination directory
    if dest_dir.exists():
        print(f"âš ï¸  Destination directory already exists; it will be overwritten: {dest_dir}")
        shutil.rmtree(dest_dir)
    dest_dir.mkdir(parents=True, exist_ok=True)

    print(f"ğŸ” Scanning source directory: {source_dir}")
    files = collect_files(source_dir)
    print(f"   â†’ {len(files)} files selected for packaging")

    print(f"ğŸ“¦ Copying files to package directory: {dest_dir}")
    manifest = copy_files(files, source_dir, dest_dir)

    print("ğŸ“ Writing manifest and README...")
    write_manifest(dest_dir, manifest, args.version)
    write_readme(dest_dir, args.version)

    if args.zip:
        print("ğŸ”§ Creating ZIP archive...")
        create_zip(dest_dir, args.version)
        print("âœ… ZIP archive created")

    print("ğŸ‰ Package build complete!")
    print(f"   â€¢ Package directory: {dest_dir}")
    if args.zip:
        archive_path = dest_dir.parent / f"HeadySystems_package_v{args.version.replace('.', '_')}.zip"
        print(f"   â€¢ Archive file: {archive_path}")

if __name__ == "__main__":
    main()
